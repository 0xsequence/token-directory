import * as fs from 'fs';
import * as path from 'path';

// This file is automatically generated by the `tools/reindex.ts` script.
const note = 'This file is automatically generated by the `tools/reindex.ts` script.';

interface IndexEntry {
  path: string;
  type: 'file' | 'directory';
  children?: IndexEntry[];
  isEmpty?: boolean;
  size?: number;
}

/**
 * Recursively scans a directory and builds an index structure
 */
function scanDirectory(dirPath: string, relativePath: string = '', deprecatedPaths: string[] = []): IndexEntry | null {
  const fullPath = path.join(dirPath, relativePath);
  
  // Skip the index.json file
  if (relativePath === 'index.json' || relativePath === 'deprecated.json') {
    return null;
  }
  
  // Skip deprecated paths
  if (deprecatedPaths.some(depPath => relativePath === depPath || relativePath.startsWith(`${depPath}/`))) {
    console.log(`Skipping deprecated path: ${relativePath}`);
    return null;
  }
  
  const stats = fs.statSync(fullPath);
  
  if (stats.isFile()) {
    // For files, return basic info
    const content = fs.readFileSync(fullPath, 'utf8');
    return {
      path: relativePath,
      type: 'file',
      isEmpty: content.trim().length === 0,
      size: stats.size
    };
  } else if (stats.isDirectory()) {
    // For directories, scan all children
    const items = fs.readdirSync(fullPath);
    const children = items.map(item => 
      scanDirectory(dirPath, path.join(relativePath, item), deprecatedPaths)
    ).filter(entry => entry !== null); // Filter out null entries (skipped files)
    
    return {
      path: relativePath || '/',
      type: 'directory',
      children
    };
  }
  
  throw new Error(`Unknown file type: ${fullPath}`);
}

/**
 * Reads the deprecated.json file and returns the list of deprecated paths
 */
function getDeprecatedPaths(indexDir: string): string[] {
  const deprecatedPath = path.join(indexDir, 'deprecated.json');
  
  if (!fs.existsSync(deprecatedPath)) {
    console.log('No deprecated.json file found, continuing without exclusions');
    return [];
  }
  
  try {
    const deprecatedContent = fs.readFileSync(deprecatedPath, 'utf8');
    const deprecatedJson = JSON.parse(deprecatedContent);
    return deprecatedJson.deprecated || [];
  } catch (error) {
    console.error('Error reading deprecated.json:', error);
    return [];
  }
}

/**
 * Main function to generate the index
 */
function generateIndex() {
  console.log('Generating index.json...');
  
  const indexDir = './index';
  
  // Ensure the index directory exists
  if (!fs.existsSync(indexDir)) {
    console.error(`Error: Directory ${indexDir} does not exist`);
    process.exit(1);
  }
  
  // Get the list of deprecated paths
  const deprecatedPaths = getDeprecatedPaths(indexDir);
  console.log(`Found ${deprecatedPaths.length} deprecated paths to exclude`);
  
  // Generate the index structure
  const indexStructure = scanDirectory(indexDir, '', deprecatedPaths);
  
  // Add metadata
  const indexJson = {
    "!!NOTE!!": note,
    index: indexStructure
  };
  
  // Write the index file
  const outputPath = path.join(indexDir, 'index.json');
  fs.writeFileSync(
    outputPath, 
    JSON.stringify(indexJson, null, 2),
    'utf8'
  );
  
  console.log(`Index successfully generated at ${outputPath}`);
}

generateIndex();

